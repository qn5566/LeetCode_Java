
### 问题描述
Koko 喜欢吃香蕉。有 `N` 堆香蕉，第 `i` 堆中有 `piles[i]` 个香蕉。护卫已经离开并将在 `H` 小时后回来。
Koko 可以决定她的每小时吃香蕉的速度 `K`。每个小时，她都会选择一些香蕉堆，并从堆中吃掉 `K` 个香蕉。
如果堆中香蕉小于 `K`，她将吃掉所有香蕉，这个小时不会再吃更多的香蕉。
Koko 喜欢慢慢地吃，但仍希望在卫兵回来之前吃完所有的香蕉。
返回 Koko 可以在 `H` 小时内吃完所有香蕉的最小整数 `K`。

### 示例
**输入：** `piles = [3,6,7,11], H = 8`
**输出：** `4`
**解释：**
Koko 每小时的吃香蕉速度为 4，需要 8 小时才能吃完所有香蕉。

### 思路
我们可以使用二分查找来解决此问题。我们可以注意到，我们可以将搜索空间的下限设置为 1，
因为 Koko 每小时必须吃至少一根香蕉。同样地，我们可以将上限设置为香蕉堆中香蕉的最大数量，因为 Koko 不能吃更多的香蕉。
具体来说，我们可以使用二分查找来找到 Koko 每小时的吃香蕉速度。对于二分查找，
我们首先要确定搜索空间的下限和上限。在这个问题中，我们已经确定了它们，所以我们可以直接进入二分查找的循环。
每次循环，我们都会将搜索空间缩小一半，并计算当前速度下需要的小时数。如果小时数小于等于 `H`，则说明这个速度可以满足要求。
我们可以尝试缩小速度的上限，以查找更小的速度。如果小时数大于 `H`，则说明这个速度太慢了，我们需要增加速度的上限，以查找更大的速度。

class Solution {
    fun minEatingSpeed(piles: IntArray, H: Int): Int {
    var left = 1
    var right = piles.max()!!

    while (left < right) {
        val mid = left + (right - left) / 2
        var hours = 0

        for (pile in piles) {
            hours += (pile + mid - 1) / mid
        }

        if (hours > H) {
            left = mid + 1
        } else {
            right = mid
        }
    }

    return left
}
}

### 复杂度分析
时间复杂度：$O(N \log W)$，其中 $N$ 是香蕉堆的数量，$W$ 是最大香蕉数。
在二分查找中，我们最多进行 $\log W$ 次迭代，每次迭代需要 $O(N)$ 的时间来计算小时数。因此总时间复杂度为 $O(N \log W)$。
空间复杂度：$O(1)$。除了几个变量之外，我们并没有使用任何额外的空间。