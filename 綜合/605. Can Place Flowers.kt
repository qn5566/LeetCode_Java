
題目描述：

假設你有一個長條花圃，其中一些區域可以種花，一些區域不能種花。你有一些花可以用來種，但是你不能將兩朵花種在相鄰的位置上。你需要在花圃中種下所有的花，並且盡可能地少使用花。

請判斷是否可以將所有的花都種下，如果可以，請返回 true；否則，返回 false。

解題思路：

我們可以從左到右遍歷整個花圃，如果當前位置沒有種花，則判斷其相鄰的前一個位置是否種花，以及相鄰的後一個位置是否種花，如果都沒有種花，則在當前位置種一朵花。如果最後能夠成功種下 $n$ 朵花，則返回 true；否則，返回 false。

需要注意的是，當種下一朵花時，我們需要將當前位置設置為已種花的狀態，以免後續的種花操作重複。

代碼實現：

class Solution {
    fun canPlaceFlowers(flowerbed: IntArray, n: Int): Boolean {
        var count = 0
        var i = 0
        while (i < flowerbed.size) {
            if (flowerbed[i] == 0 && (i == 0 || flowerbed[i-1] == 0) && (i == flowerbed.size - 1 || flowerbed[i+1] == 0)) {
                flowerbed[i] = 1
                count++
            }
            i++
        }
        return count >= n
    }
}

這個問題是要你判斷是否可以在一個長度為 m 的花圃中種下 n 朵花。其中花圃用一個整數陣列 flowerbed 來表示，
陣列中的每個元素可以是 0 或 1，表示這個位置上是否已經種了花。在種花的時候，相鄰的花不能重疊，
也就是說如果相鄰的位置都已經種了花，那麼這個位置不能再種花了。
請你實現一個函數 canPlaceFlowers，來判斷在這個花圃中是否能夠種下 n 朵花。如果能夠種下，則返回 true，否則返回 false。
