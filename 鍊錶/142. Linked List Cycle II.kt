
## 142. 环形链表 II

### 问题描述

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。

### 示例

**输入：** `head = [3,2,0,-4], pos = 1`

**输出：** `tail connects to node index 1`

**解释：**
链表中有一个环，其尾部连接到第二个节点。

### 思路

我们可以使用 Floyd's Tortoise and Hare 算法来检测链表中是否有环。该算法涉及两个指针 - 慢指针和快指针。慢指针每次移动一步，而快指针每次移动两步。如果链表有环，快指针最终会追上慢指针。

一旦我们知道链表中有环，就可以使用以下方法找到环开始的节点：

1. 让 `p1` 为链表的头，`p2` 为前一步两个指针相遇的节点。
2. 将 `p1` 和 `p2` 每次移动一步，直到它们在环开始的节点相遇。

### 代码实现

以下是 Kotlin 代码实现：

class Solution {
    fun detectCycle(head: ListNode?): ListNode? {
    if (head == null) {
        return null
    }

    var slow = head
    var fast = head

    while (fast?.next != null) {
        slow = slow?.next
        fast = fast.next?.next

        if (slow == fast) {
            var p1 = head
            var p2 = fast

            while (p1 != p2) {
                p1 = p1?.next
                p2 = p2?.next
            }

            return p1
        }
    }

        return null
    }
}

### 复杂度分析

时间复杂度：$O(N)$，其中 $N$ 是链表中的节点数。Floyd's 算法需要 $O(N)$ 的时间来检测链表中的环，第二次遍历链表以查找环的起始节点最多需要 $O(N)$ 的时间。

空间复杂度：$O(1)$。我们只使用了常量级别的额外空间。

Floyd's 算法，也称为龟兔赛跑算法，是一种用于检测链表中是否存在环的算法。该算法使用两个指针，一个慢指针和一个快指针，在链表中同时移动。如果链表中存在环，那么快指针最终会追上慢指针，从而检测到环的存在。此算法的时间复杂度为 $O(N)$，其中 $N$ 是链表中的节点数。

為什麼有環  `head = [3,2,0,-4], pos = 1`   ?

这里我们可以看到 `pos` 的值是 1，这意味着从链表的第二个节点开始，存在一个环。具体来说，第一个节点是 3，第二个节点是 2，第三个节点是 0，第四个节点是 -4，第五个节点是 2，它指向第二个节点。因此，这个链表是有环的。

為什麼第5個節點是2

因为链表中存在一个环，该环从第二个节点开始，因此从第五个节点开始，它将指向第二个节点，即值为2的节点。

pos 範例有好像是需要輸入，但實作的時候卻沒地方輸入？

这个文档列出了两个Leetcode题目的题意、思路和代码实现。关于pos的问题，pos是作为题目的输入给出的，可以在Leetcode平台上输入测试用例时指定。在代码实现中没有直接输入pos，而是通过链表的节点关系来判断链表中是否存在环，从而找到环的开始节点。

这里使用了 Kotlin 的安全调用操作符 `?.`。它的作用是在调用一个可能为空的对象的方法或属性时，如果对象为空则不会抛出 `NullPointerException`，而是返回 `null`。

fast?.next 為什麼要加問號 ?

在这个代码中，`fast?.next` 可能返回 `null`，因为 `fast` 可能已经到达了链表的末尾。如果没有使用安全调用操作符，则在这种情况下会抛出 `NullPointerException`。因此，使用安全调用操作符可以避免这种情况。