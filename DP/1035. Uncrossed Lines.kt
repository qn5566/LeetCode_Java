题目要求我们找到两个数组 A 和 B 之间最长的不相交连线的数量。

为了解决这个问题，我们可以使用动态规划来进行求解。我们定义一个二维数组 dp，其中 dp[i][j] 表示 A 数组的前 i 个元素和 B 数组的前 j 个元素之间最长的不相交连线的数量。

我们可以使用以下递推关系来计算 dp 数组：

如果 A[i-1] == B[j-1]，说明 A[i-1] 和 B[j-1] 可以构成一条连线，因此 dp[i][j] = dp[i-1][j-1] + 1。
如果 A[i-1] != B[j-1]，说明 A[i-1] 和 B[j-1] 无法构成连线，我们需要在 A 数组的前 i-1 个元素和 B 数组的前 j 个元素之间找到最长的不相交连线数量，或者在 A 数组的前 i 个元素和 B 数组的前 j-1 个元素之间找到最长的不相交连线数量。因此，dp[i][j] = max(dp[i-1][j], dp[i][j-1])。
最后，dp[A.length][B.length] 即为所求的最长不相交连线的数量。

使用这种动态规划的方法，我们可以在时间复杂度为 O(m*n) 的情况下解决这个问题，其中 m 是 A 数组的长度，n 是 B 数组的长度。


这是使用动态规划（Dynamic Programming）解决的问题。
动态规划是一种通过将问题分解为子问题并存储子问题的解来解决复杂问题的方法。
在这个问题中，我们使用动态规划来计算最长不相交连线的数量。

具体而言，我们定义一个二维数组 dp，其中 dp[i][j] 表示 nums1 的前 i 个元素和 nums2 的前 j 个元素之间的最长不相交连线的数量。
我们通过填充 dp 数组来逐步计算更大规模的子问题，直到得到最终的解。

在填充 dp 数组时，我们遍历 nums1 和 nums2 的每个元素，并根据元素是否相等来更新 dp 数组的值。
如果 nums1[i - 1] 等于 nums2[j - 1]，表示第 i 个元素和第 j 个元素可以形成一条连线，
因此我们将 dp[i][j] 更新为 dp[i - 1][j - 1] + 1。
如果不相等，则取 dp[i - 1][j] 和 dp[i][j - 1] 中的较大值，表示不使用第 i 个元素或不使用第 j 个元素时的最大连线数量。

最后，我们返回 dp[m][n]，即为最长不相交连线的数量。

这种动态规划解法能够有效地解决具有重叠子问题的问题，并通过存储子问题的解来避免重复计算，从而提高算法的效率。

class Solution {
    fun maxUncrossedLines(nums1: IntArray, nums2: IntArray): Int {
        val m = nums1.size
        val n = nums2.size
        val dp = Array(m + 1) { IntArray(n + 1) }
        
        for (i in 1..m) {
            for (j in 1..n) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1
                } else {
                    dp[i][j] = maxOf(dp[i - 1][j], dp[i][j - 1])
                }
            }
        }
        
        return dp[m][n]
    }
}