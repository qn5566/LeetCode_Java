這個問題是關於一個遊戲，稱為「新21點遊戲」。遊戲的規則如下：

你從0開始，每次可以從1到W中選擇一個數字加到你的當前分數上。你的目標是使你的分數不超過K，並且最終的分數是N以下的最大值。

在這個問題中，我們需要計算在遵守遊戲規則的情況下，最終分數小於等於N的概率是多少。

解題思路如下：

首先處理一些特殊情況：
如果K等於0，或者N大於等於K+W，表示你可以直接達到最終分數，返回概率1.0。
創建一個長度為N+1的數組dp，其中dp[i]表示當前分數為i的概率。
初始化dp[0]為1.0，表示初始分數為0的概率為1.0。
使用迴圈從1到N進行遍歷，計算每個分數的概率：
將當前分數i的概率設為前W個分數的概率之和除以W，即dp[i] = sumW / W。
如果i小於K，將當前分數的概率添加到sumW中，以便在後續計算中使用。
如果i大於等於K，將當前分數的概率加到結果res中，表示符合條件的分數。
如果i - W大於等於0，從sumW中減去分數為i-W的概率，因為這些概率已經被考慮過了。
返回結果res，表示最終分數小於等於N的概率。
這個解法使用動態規劃的思想，通過計算每個分數的概率，並利用前一個分數的概率計算當前分數的概率。最終得到的結果就是所求的概率。


class Solution {
    fun new21Game(N: Int, K: Int, W: Int): Double {
        if (K == 0 || N >= K + W) return 1.0
        val dp = DoubleArray(N + 1)
        dp[0] = 1.0
        var sumW = 1.0
        var res = 0.0
        for (i in 1..N) {
            dp[i] = sumW / W
            if (i < K) sumW += dp[i]
            else res += dp[i]
            if (i - W >= 0) sumW -= dp[i - W]
        }
        return res
    }
}
