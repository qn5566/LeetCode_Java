


這段程式碼是無法達成題目要求的，必須在函數中加入實作。
題目要求你重新排列有向邊，使得所有的邊都指向城市 0，且重新排列最少的邊。
在這個問題中，我們可以使用深度優先搜索（DFS）來解決。首先，我們需要建立一個鄰接表來表示城市之間的關係。
然後，我們可以開始搜索。
從城市 0 開始，遍歷每一個與它相連通的城市。如果從城市 0 到達該城市的邊是正向的（即指向該城市），
我們需要將它反轉為負向的，並且將答案加 1。然後，我們繼續遞迴地搜索從該城市出發的所有邊，直到所有的邊都被處理過為止。最後，返回總共需要反轉的邊數即可。

以下是具體的實現方式：


class Solution {
    fun minReorder(n: Int, connections: Array<IntArray>): Int {
        val graph = Array(n) { mutableSetOf<Int>() }
        val visited = BooleanArray(n)
        var count = 0
        
        // 建立有向圖
        for (conn in connections) {
            graph[conn[0]].add(conn[1]) // 正向邊
            graph[conn[1]].add(-conn[0]) // 反向邊
        }
        
        // DFS 訪問所有點
        fun dfs(node: Int) {
            visited[node] = true
            for (next in graph[node]) {
                if (!visited[Math.abs(next)]) { // 如果還沒訪問過
                    if (next > 0) count++ // 正向邊，需要改變方向
                    dfs(Math.abs(next)) // 繼續訪問下一個點
                }
            }
        }
        
        dfs(0) // 從 0 號點開始訪問
        return count
    }
}


首先，我们定义了一个函数 minReorder，它接收两个参数：n 表示城市的个数，connections 是一个二维数组，
其中每个元素表示一条边连接的两个城市。函数返回一个整数，表示将某些边的方向更改后，让所有城市都能够到达城市 0 的最小操作次数。
在函数内部，我们首先创建一个大小为 n 的有向图 graph，其中每个元素是一个可变的整型集合，用于存储与该节点有直接连接的节点。
同时，我们还创建了一个大小为 n 的布尔型数组 visited，用于记录节点是否被访问过。
然后，我们通过循环遍历 connections 数组，将边连接的两个城市加入到有向图 graph 中，同时，
我们也需要将这条边的反向边也加入到有向图中，这是因为我们需要通过反向边来确定哪些边需要改变方向。
接下来，我们定义了一个名为 dfs 的函数，它接收一个整数参数 node，表示要从哪个节点开始进行 DFS 遍历。在函数内部，
我们首先将当前节点 node 标记为已访问，然后遍历与该节点相邻的所有节点。如果这个相邻节点还没有被访问过，
我们就需要对它进行 DFS 遍历，因此我们将这个节点作为参数调用 dfs 函数。在这个过程中，如果遍历到的边是正向边，
我们需要将变量 count 的值加一，表示这条边需要改变方向才能到达城市 0。
最后，我们调用 dfs 函数，从节点 0 开始遍历整个图，并返回变量 count 的值，即为最小操作次数。