You are given an array of integers a. A new array b is generated by rearranging the elements of a in the following way:

b[0] is equal to a[0];
b[1] is equal to the last element of a;
b[2] is equal to a[1];
b[3] is equal to the second-last element of a;
b[4] is equal to a[2];
b[5] is equal to the third-last element of a;
and so on.
Your task is to determine whether the new array b is sorted in strictly ascending order or not.

Here is how the process of generating the new array b works:
Example

For a = [1, 3, 5, 6, 4, 2], the output should be solution(a) = true.

The new array b will look like [1, 2, 3, 4, 5, 6], which is in strictly ascending order, so the answer is true.

For a = [1, 4, 5, 6, 3], the output should be solution(a) = false.

The new array b will look like [1, 3, 4, 6, 5], which is not in strictly ascending order, so the answer is false.

好的，那我們可以開始思考如何解決這個問題。
首先，根據題目描述，新數組b的第一個元素是a的第一個元素，
第二個元素是a的最後一個元素，第三個元素是a的第二個元素，第四個元素是a的倒數第二個元素，以此類推。
因此，我們可以先創建一個新數組b，按照上述規則填充元素。
接下來，只需要遍歷新數組b，檢查它是否按照嚴格遞增的順序排序即可。
如果新數組b是按照嚴格遞增的順序排序的，那麼最後一個元素b[n-1]必然大於第一個元素b[0]。
否則，新數組b不是按照嚴格遞增的順序排序的。
因此，我們可以在遍歷新數組b的同時檢查是否有b[i] <= b[i-1]的情況發生。
如果有，則新數組b不是按照嚴格遞增的順序排序的。如果遍歷完新數組b都沒有發現這種情況，
那麼新數組b就是按照嚴格遞增的順序排序的。
可以使用双指针算法来解决这个问题。左指针指向 b 的开头，右指针指向 b 的结尾。
然后我们依次比较 b 的左右两侧的元素，如果左侧元素大于右侧元素，则返回 false。
如果左右两侧的元素都比较完了，都没有发现逆序对，则返回 true。
以下是使用双指针算法的 Kotlin 代码实现：

fun solution(a: MutableList<Int>): Boolean {
    val n = a.size
    val b = mutableListOf<Int>()
    var i = 0
    var j = n - 1

    while (i <= j) {
        if (i == j) {
            b.add(a[i])
            break
        }
        b.add(a[i])
        b.add(a[j])
        i++
        j--
    }

    for (k in 1 until n) {
        if (b[k] <= b[k - 1]) {
            return false
        }
    }
    return true
}
